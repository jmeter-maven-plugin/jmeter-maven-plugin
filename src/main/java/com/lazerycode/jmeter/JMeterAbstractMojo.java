package com.lazerycode.jmeter;

import com.lazerycode.jmeter.configuration.JMeterArgumentsArray;
import com.lazerycode.jmeter.configuration.ProxyConfiguration;
import com.lazerycode.jmeter.configuration.RemoteConfiguration;
import com.lazerycode.jmeter.properties.PropertyHandler;
import com.lazerycode.jmeter.threadhandling.JMeterPluginSecurityManager;
import com.lazerycode.jmeter.threadhandling.JMeterPluginUncaughtExceptionHandler;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.resolver.AbstractArtifactResolutionException;
import org.apache.maven.artifact.resolver.ArtifactNotFoundException;
import org.apache.maven.artifact.resolver.ArtifactResolutionException;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.project.MavenProject;
import org.apache.maven.project.MavenProjectBuilder;
import org.apache.maven.project.ProjectBuildingException;
import org.apache.maven.project.artifact.InvalidDependencyVersionException;
import org.joda.time.format.DateTimeFormat;

import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.Enumeration;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

import static com.lazerycode.jmeter.UtilityFunctions.isSet;
import static org.apache.commons.io.FileUtils.copyFile;
import static org.apache.commons.io.FileUtils.copyInputStreamToFile;

/**
 * JMeter Maven plugin.
 * This is a base class for the JMeter mojos.
 *
 * @author Tim McCune
 */
@SuppressWarnings({"UnusedDeclaration", "FieldCanBeLocal", "JavaDoc"}) // Mojos get their fields set via reflection
public abstract class JMeterAbstractMojo extends AbstractMojo {

	/**
	 * Sets the list of include patterns to use in directory scan for JMX files.
	 * Relative to testFilesDirectory.
	 *
	 * @parameter
	 */
	protected List<String> testFilesIncluded;

	/**
	 * Sets the list of exclude patterns to use in directory scan for Test files.
	 * Relative to testFilesDirectory.
	 *
	 * @parameter
	 */
	protected List<String> testFilesExcluded;

	/**
	 * Path under which JMX files are stored.
	 *
	 * @parameter expression="${jmeter.testfiles.basedir}"
	 * default-value="${basedir}/src/test/jmeter"
	 */
	protected File testFilesDirectory;

	/**
	 * Timestamp the test results.
	 *
	 * @parameter default-value="true"
	 */
	protected boolean testResultsTimestamp;

	/**
	 * Append the results timestamp to the filename
	 * (It will be prepended by default if testResultsTimestamp is set to true)
	 *
	 * @parameter default-value="false"
	 */
	protected boolean appendResultsTimestamp;

	/**
	 * Set the format of the timestamp that is appended to the results filename.
	 * (This assumes that testResultsTimestamp is set to 'true')
	 * For formatting see http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html
	 *
	 * @parameter default-value=""
	 */
	protected String resultsFileNameDateFormat;

	/**
	 * Set the format of the results generated by JMeter
	 * Valid values are: xml, csv (XML set by default).
	 *
	 * @parameter default-value="xml"
	 */
	protected String resultsFileFormat;

	/**
	 * Absolute path to JMeter custom (test dependent) properties file.
	 * .
	 *
	 * @parameter default-value="${propertiesJMeter}"
	 */
	protected Map<String, String> propertiesJMeter;

	/**
	 * JMeter Properties that are merged with precedence into default JMeter file in saveservice.properties
	 *
	 * @parameter
	 */
	protected Map<String, String> propertiesSaveService;

	/**
	 * JMeter Properties that are merged with precedence into default JMeter file in upgrade.properties
	 *
	 * @parameter
	 * @description JMeter Properties that are merged with precedence into default JMeter file in 'upgrade.properties'.
	 */
	protected Map<String, String> propertiesUpgrade;

	/**
	 * JMeter Properties that are merged with precedence into default JMeter file in user.properties
	 * user.properties takes precedence over jmeter.properties
	 *
	 * @parameter
	 * @description JMeter Properties that are merged with precedence into default JMeter file in 'user.properties'
	 * user.properties takes precedence over 'jmeter.properties'.
	 */
	protected Map<String, String> propertiesUser;

	/**
	 * JMeter Global Properties that override those given in jmeterProps. <br>
	 * This sets local and remote properties (JMeter's definition of global properties is actually remote properties)
	 * and overrides any local/remote properties already set
	 *
	 * @description JMeter Global Properties that override those given in jmeterProps. <br>
	 * This sets local and remote properties (JMeter's definition of global properties is actually remote properties)
	 * and overrides any local/remote properties already set.
	 */
	protected Map<String, String> propertiesGlobal;

	/**
	 * (Java) System properties set for the test run.
	 * Properties are merged with precedence into default JMeter file system.properties
	 *
	 * @parameter Java merged with precedence into default JMeter file system.properties.
	 */
	protected Map<String, String> propertiesSystem;

	/**
	 * Absolute path to JMeter custom (test dependent) properties file.
	 *
	 * @parameter
	 */
	protected File customPropertiesFile;

	/**
	 * Replace the default JMeter properties with any custom properties files supplied.
	 * (If set to false any custom properties files will be merged with the default JMeter properties files, custom properties will overwrite default ones)
	 *
	 * @parameter default-value="true"
	 */
	protected boolean propertiesReplacedByCustomFiles;

	/**
	 * Value class that wraps all proxy configurations.
	 *
	 * @parameter default-value="${proxyConfig}"
	 */
	protected ProxyConfiguration proxyConfig;

	/**
	 * Value class that wraps all remote configurations.
	 *
	 * @parameter default-value="${remoteConfig}"
	 */
	protected RemoteConfiguration remoteConfig;

	/**
	 * Set a root log level to override all log levels used by JMeter
	 * Valid log levels are: FATAL_ERROR, ERROR, WARN, INFO, DEBUG (They are not case sensitive);
	 * If you try to set an invalid log level it will be ignored
	 *
	 * @parameter default-value=""
	 */
	protected String overrideRootLogLevel;

	/**
	 * Sets whether FailureScanner should ignore failures in JMeter result file.
	 * <p/>
	 * Failures are for example failed requests
	 *
	 * @parameter expression="${jmeter.ignore.failure}" default-value=false
	 */
	protected boolean ignoreResultFailures;

	/**
	 * Suppress JMeter output
	 *
	 * @parameter default-value="true"
	 */
	protected boolean suppressJMeterOutput;

	/**
	 * @parameter expression="${project}"
	 * @required
	 * @readonly
	 */
	protected MavenProject mavenProject;

	/**
	 * Get a list of artifacts used by this plugin
	 *
	 * @parameter default-value="${plugin.artifacts}"
	 * @required
	 * @readonly
	 */
	protected List<Artifact> pluginArtifacts;

	/**
	 * @component
	 * */
	private org.apache.maven.artifact.factory.ArtifactFactory artifactFactory;

	/**
	 * @component
	 * */
	private MavenProjectBuilder mavenProjectBuilder;

	/**
	 * @component
	 * */
	private org.apache.maven.artifact.resolver.ArtifactResolver resolver;

	/**
	 * @parameter default-value="${localRepository}"
	 * */
	private org.apache.maven.artifact.repository.ArtifactRepository localRepository;

	/**
	 * @parameter default-value="${project.remoteArtifactRepositories}"
	 * */
	@SuppressWarnings("rawtypes")
	private java.util.List remoteRepositories;

	/**
	 * Skip the JMeter tests
	 *
	 * @parameter default-value="false"
	 */
	protected boolean skipTests;

	//------------------------------------------------------------------------------------------------------------------

	/**
	 * JMeter outputs.
	 *
	 * @parameter expression="${project.build.directory}/jmeter"
	 * @description Place where the JMeter files will be generated.
	 */
	protected transient File workDir;

	/**
	 * Other directories will be created by this plugin and used by JMeter
	 */
	protected File binDir;
	protected File libDir;
	protected File libExtDir;
	protected File logsDir;
	protected File resultsDir;

	/**
	 * All property files are stored in this artifact, comes with JMeter library
	 */
	protected final static String JMETER_CONFIG_ARTIFACTID = "ApacheJMeter_config";
	protected final static String JMETER_GROUP_ID = "org.apache.jmeter";

	protected JMeterArgumentsArray testArgs;
	protected PropertyHandler pluginProperties;
	protected boolean resultsOutputIsCSVFormat = false;

	//==================================================================================================================

	/**
	 * Generate the directory tree utilised by JMeter.
	 */
	@SuppressWarnings("ResultOfMethodCallIgnored")
	protected void generateJMeterDirectoryTree() {
		logsDir = new File(workDir, "logs");
		logsDir.mkdirs();
		binDir = new File(workDir, "bin");
		binDir.mkdirs();
		resultsDir = new File(workDir, "results");
		resultsDir.mkdirs();
		libDir = new File(workDir, "lib");
		libExtDir = new File(libDir, "ext");
		libExtDir.mkdirs();

		//JMeter expects a <workdir>/lib/junit directory and complains if it can't find it.
		new File(libDir, "junit").mkdirs();
	}

	protected void propertyConfiguration() throws MojoExecutionException {
		pluginProperties = new PropertyHandler(testFilesDirectory, binDir, getArtifactNamed(JMETER_CONFIG_ARTIFACTID), propertiesReplacedByCustomFiles);
		pluginProperties.setJMeterProperties(propertiesJMeter);
		pluginProperties.setJMeterGlobalProperties(propertiesGlobal);
		pluginProperties.setJMeterSaveServiceProperties(propertiesSaveService);
		pluginProperties.setJMeterUpgradeProperties(propertiesUpgrade);
		pluginProperties.setJmeterUserProperties(propertiesUser);
		pluginProperties.setJMeterSystemProperties(propertiesSystem);
		pluginProperties.configureJMeterPropertiesFiles();
		pluginProperties.setDefaultPluginProperties(binDir.getAbsolutePath());
	}

	/**
	 * Create the JMeter directory tree and copy all compile time JMeter dependencies into it.
	 * Generic compile time artifacts are copied into the libDir
	 * ApacheJMeter_* artifacts are copied into the libExtDir
	 * Runtime dependencies set by the user are also copied into the libExtDir
	 *
	 * @throws MojoExecutionException
	 */
	protected void populateJMeterDirectoryTree() throws MojoExecutionException {
		// Copy any jars required for libDir.
		populateJMeterParentDependencies();

		// Extract ApacheJMeter_config jar
		Artifact configArtifact = artifactFactory.createArtifact(JMETER_GROUP_ID, JMETER_CONFIG_ARTIFACTID, "2.9", null, "jar");
		try {
			resolver.resolve(configArtifact, remoteRepositories, localRepository);
			JarFile configSettings = new JarFile(configArtifact.getFile());
			Enumeration<JarEntry> entries = configSettings.entries();

			while (entries.hasMoreElements()) {
				JarEntry jarFileEntry = entries.nextElement();
				// Only interested in files in the /bin directory
				// that are not properties files
				if (!jarFileEntry.isDirectory() && jarFileEntry.getName().startsWith("bin") && !jarFileEntry.getName().endsWith(".properties")) {
					copyInputStreamToFile(configSettings.getInputStream(jarFileEntry), new File(workDir.getCanonicalPath() + File.separator + jarFileEntry.getName()));
				}
			}

			configSettings.close();
		} catch (AbstractArtifactResolutionException e) {
			throw new MojoExecutionException("Unable to find the JMeter " + JMETER_CONFIG_ARTIFACTID + " :" + e);
		} catch (IOException e) {
			throw new MojoExecutionException("Unable to extract the JMeter " + JMETER_CONFIG_ARTIFACTID + " jar :" + e);
		}

		// Copy Only ApacheJMeter dependencies to libExtDir
		for (Artifact artifact : pluginArtifacts) {
			try {
				if (isArtifactAJMeterDependency(artifact)) {
					copyFile(artifact.getFile(), new File(libExtDir + File.separator + artifact.getFile().getName()));
				}
			} catch (IOException e) {
				throw new MojoExecutionException("Unable to populate the JMeter directory tree: " + e);
			}
		}
		//Clear down classpath and let JMeter manage it, errors will occur if this is not done.
		System.setProperty("java.class.path", "");
	}

	/**
	 * This method copy ApacheJMeter_parent.pom dependencies to libDir. We DONOT
	 * resolve transitively inorder to copy ONLY dependencies implicitly
	 * declared at ApacheJMeter_parent.pom.
	 * 
	 * TODO -Get JMeter version from pom property e.g. jmeter.version
	 * 
	 * @throws MojoExecutionException
	 */
	protected void populateJMeterParentDependencies() throws MojoExecutionException {
		try {
			// Copy jorphan Artifact
			Artifact jorphanArtifact = artifactFactory.createArtifact("org.apache.jmeter", "jorphan", "2.9", null, "jar");
			resolver.resolve(jorphanArtifact, remoteRepositories, localRepository);
			copyFile(jorphanArtifact.getFile(), new File(libDir + File.separator + jorphanArtifact.getFile().getName()));

			// Copy All dependencies from ApacheJMeter_parent
			Artifact pomArtifact = artifactFactory.createArtifact("org.apache.jmeter", "ApacheJMeter_parent", "2.9", null, "pom");
			resolver.resolve(pomArtifact, remoteRepositories, localRepository);

			MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, remoteRepositories, localRepository);
			@SuppressWarnings("unchecked")
			Collection<Artifact> artifacts = (Collection<Artifact>) pomProject.createArtifacts(artifactFactory, null, null);

			for (Artifact artifact : artifacts) {
				resolver.resolve(artifact, remoteRepositories, localRepository);

				if (Artifact.SCOPE_COMPILE.equals(artifact.getScope())) {
					copyFile(artifact.getFile(), new File(libDir + File.separator + artifact.getFile().getName()));
				}
			}
		} catch (ArtifactResolutionException e) {
			throw new MojoExecutionException("Unable to populate the JMeter Parent Dependencies: " + e);
		} catch (ArtifactNotFoundException e) {
			throw new MojoExecutionException("Unable to populate the JMeter Parent Dependencies: " + e);
		} catch (ProjectBuildingException e) {
			throw new MojoExecutionException("Unable to populate the JMeter Parent Dependencies: " + e);
		} catch (InvalidDependencyVersionException e) {
			throw new MojoExecutionException("Unable to populate the JMeter Parent Dependencies: " + e);
		} catch (IOException e) {
			throw new MojoExecutionException("Unable to populate the JMeter Parent Dependencies: " + e);
		}
	}

	/**
	 * Work out if an artifact is a JMeter dependency
	 * 
	 * @param artifact
	 *            Artifact to examine
	 * @return true if a Jmeter (ArtifactId Start with ApacheJMeter) dependency,
	 *         false if a other dependency.
	 */
	protected boolean isArtifactAJMeterDependency(Artifact artifact) {
		if (artifact.getArtifactId().startsWith("ApacheJMeter")) {
			return true;
		}
		return false;
	}

	/**
	 * Search the list of plugin artifacts for an artifact with a specific name
	 *
	 * @param artifactName
	 * @return
	 * @throws MojoExecutionException
	 */
	protected Artifact getArtifactNamed(String artifactName) throws MojoExecutionException {
		for (Artifact artifact : pluginArtifacts) {
			if (artifact.getArtifactId().equals(artifactName)) {
				return artifact;
			}
		}
		throw new MojoExecutionException("Unable to find artifact '" + artifactName + "'!");
	}

	/**
	 * Generate the initial JMeter Arguments array that is used to create the command line that we pass to JMeter.
	 *
	 * @throws MojoExecutionException
	 */
	protected void initialiseJMeterArgumentsArray(boolean disableGUI) throws MojoExecutionException {
		testArgs = new JMeterArgumentsArray(disableGUI, workDir.getAbsolutePath());
		testArgs.setResultsDirectory(resultsDir.getAbsolutePath());
		testArgs.setResultFileOutputFormatIsCSV(resultsOutputIsCSVFormat);
		if (testResultsTimestamp) {
			testArgs.setResultsTimestamp(testResultsTimestamp);
			testArgs.appendTimestamp(appendResultsTimestamp);
			if (isSet(resultsFileNameDateFormat)) {
				try {
					testArgs.setResultsFileNameDateFormat(DateTimeFormat.forPattern(resultsFileNameDateFormat));
				} catch (Exception ex) {
					getLog().error("'" + resultsFileNameDateFormat + "' is an invalid DateTimeFormat.  Defaulting to Standard ISO_8601.");
				}
			}
		}
		testArgs.setProxyConfig(proxyConfig);
		testArgs.setACustomPropertiesFile(customPropertiesFile);
		testArgs.setLogRootOverride(overrideRootLogLevel);
	}

	protected void setJMeterResultFileFormat() {
		if (resultsFileFormat.toLowerCase().equals("csv")) {
			propertiesJMeter.put("jmeter.save.saveservice.output_format", "csv");
			resultsOutputIsCSVFormat = true;
		} else {
			propertiesJMeter.put("jmeter.save.saveservice.output_format", "xml");
			resultsOutputIsCSVFormat = false;
		}
	}

	/**
	 * Wait for one of the JMeterThreads in the list to stop.
	 */
	protected void waitForTestToFinish(List<String> threadNames) throws InterruptedException {
		Thread waitThread = null;
		Set<Thread> threadSet = Thread.getAllStackTraces().keySet();
		for (Thread thread : threadSet) {
			for (String threadName : threadNames) {
				if (threadName.equals(thread.getName())) {
					waitThread = thread;
					break;
				}
			}
		}
		if (waitThread != null) {
			waitThread.setUncaughtExceptionHandler(new JMeterPluginUncaughtExceptionHandler());
			waitThread.join();
		}
	}

	/**
	 * Capture System.exit commands so that we can check to see if JMeter is trying to kill us without warning.
	 *
	 * @return old SecurityManager so that we can switch back to normal behaviour.
	 */
	protected SecurityManager overrideSecurityManager() {
		SecurityManager oldManager = System.getSecurityManager();
		System.setSecurityManager(new JMeterPluginSecurityManager());
		return oldManager;
	}

	/**
	 * Override System.exit(0) to ensure JMeter doesn't kill us without warning.
	 *
	 * @return old UncaughtExceptionHandler so that we can switch back to normal behaviour.
	 */
	protected Thread.UncaughtExceptionHandler overrideUncaughtExceptionHandler() {
		Thread.UncaughtExceptionHandler oldHandler = Thread.getDefaultUncaughtExceptionHandler();
		Thread.setDefaultUncaughtExceptionHandler(new JMeterPluginUncaughtExceptionHandler());
		return oldHandler;
	}
}
